# ARM64 汇编寄存器依赖追踪器

## 功能说明

这个工具可以从一个汇编跳转指令（如 `BR X3`）向上递归追踪寄存器的赋值链，找出所有参与给该寄存器赋值的指令，直到找到静态赋值指令（如 MOV 立即数、ADRP 等）。

## 使用方法

### 基本用法

```bash
python register_tracer.py
```

默认会分析 `sample.txt` 文件的第58行指令。

### 自定义分析

在 `register_tracer.py` 的 `main()` 函数中修改以下参数：

```python
# 修改要分析的文件名
filename = 'your_file.txt'

# 修改要分析的行号
target_line = 58
```

## 核心功能

### 1. 指令解析

- 解析 ARM64 汇编指令格式
- 识别指令的操作码和操作数
- 提取目标寄存器和源寄存器

### 2. 寄存器追踪

算法会向上递归追踪以下类型的寄存器依赖：

#### 完全静态指令（追踪终止）
- `MOV Xn, #立即数` - 将立即数加载到寄存器
- `ADRP Xn, #地址` - 加载页地址
- `ADR Xn, #地址` - 加载地址

#### 部分静态指令（继续追踪）
- `MOVK Xn, #立即数` - 修改寄存器的部分位，需要追踪该寄存器之前的 MOV 指令
- `ADD Xn, Xm, Xp` - 寄存器相加，需要追踪 Xm 和 Xp
- `LDR Xn, [Xm, Xp]` - 从内存加载，需要追踪地址相关的寄存器
- `CSEL Xn, Xm, Xp, 条件` - 条件选择，需要追踪 Xm 和 Xp

### 3. 输出结果

程序会输出：

1. **追踪起始指令**：显示从哪条指令开始分析
2. **相关指令列表**：按行号排序的所有相关指令
3. **每条指令的详细信息**：
   - 目标寄存器（被赋值的寄存器）
   - 源寄存器（参与计算的寄存器）
   - 是否为静态赋值
4. **寄存器依赖关系图**：直观显示寄存器之间的依赖关系

## 示例输出

```
追踪起始指令（第58行）:
  .text:00000000002DA0F4                 BR              X3

相关指令追踪结果（共16条）:
================================================================================

第42行: .text:00000000002DA0B4                 ADD             X3, X1, X24
  目标寄存器: X3
  源寄存器: {'X1', 'X24'}
  静态赋值: 否

第34行: .text:00000000002DA094                 LDR             X1, [X9,X13]
  目标寄存器: X1
  源寄存器: {'X13', 'X9'}
  静态赋值: 否

...

寄存器依赖关系:
================================================================================
X3 ← {'X1', 'X24'} (第42行)
X1 ← {'X13', 'X9'} (第34行)
X9 ← {'X11'} (第24行)
...
```

## 算法特点

### 1. 递归追踪
- 从目标寄存器开始，递归追踪所有依赖的源寄存器
- 处理多层依赖关系（如 X3 依赖 X1，X1 依赖 X9）

### 2. 避免重复
- 使用 `(寄存器, 起始行号)` 对来避免重复追踪
- 支持同一寄存器在不同位置的多次赋值

### 3. 立即数组装处理
- 正确处理 ARM64 的 64位立即数组装模式
- 追踪 MOV + 多个 MOVK 的完整序列

### 4. 寄存器映射
- 自动处理 W 寄存器和 X 寄存器的映射关系
- W0 到 W30 自动映射到 X0 到 X30

## 技术细节

### 支持的指令类型

#### 数据传输指令
- `MOV`, `MOVK`, `MOVZ`, `MOVN` - 数据移动
- `LDR`, `LDUR` - 加载
- `STR`, `STUR`, `STP` - 存储

#### 算术/逻辑指令
- `ADD`, `SUB` - 加减运算
- `AND`, `ORR`, `EOR` - 位运算

#### 分支指令
- `BR`, `BLR` - 寄存器跳转
- `B`, `BL` - 直接跳转

#### 条件指令
- `CSEL`, `CSINC`, `CSINV` - 条件选择
- `CMP`, `CMN`, `TST` - 比较测试

### 寄存器标准化
- X0-X30: 64位通用寄存器
- W0-W30: 32位通用寄存器（对应X寄存器的低32位）
- XZR/WZR: 零寄存器
- SP: 栈指针
- 系统寄存器: TPIDR_EL0 等（不追踪）

## 扩展用途

这个工具可以用于：

1. **混淆代码分析**：追踪经过混淆的跳转目标
2. **漏洞研究**：分析控制流劫持点
3. **逆向工程**：理解复杂的寄存器操作链
4. **代码审计**：检查间接跳转的来源

## 限制和注意事项

1. **内存访问**：LDR 指令的追踪只到地址寄存器，不追踪内存中的实际值
2. **条件执行**：不考虑指令是否真正执行（条件标志）
3. **循环依赖**：如果存在循环依赖（如 `ADD X9, X9, X12`），只追踪到首次定义
4. **函数调用**：不跨越函数调用边界追踪参数传递

## 文件结构

```
register_tracer.py    # 主程序
sample.txt            # 示例汇编代码
README.md             # 本说明文档
```

## 类和方法说明

### `Instruction` 类
存储单条指令的信息：
- `line_num`: 行号
- `address`: 指令地址
- `opcode`: 操作码
- `operands`: 操作数
- `full_line`: 完整的原始行

### `RegisterTracer` 类

#### 核心方法
- `trace_register(target_reg, start_line)`: 递归追踪寄存器
- `trace_from_instruction(line_num)`: 从指定行开始追踪
- `get_destination_register(inst)`: 获取目标寄存器
- `get_source_registers(inst)`: 获取源寄存器
- `is_static_assignment(inst)`: 判断是否为静态赋值
- `is_initial_value_instruction(inst)`: 判断是否为初始赋值

#### 辅助方法
- `parse_instruction_line(line, line_num)`: 解析指令行
- `normalize_register(reg)`: 标准化寄存器名
- `extract_registers_from_operand(operand)`: 从操作数提取寄存器
- `print_trace_result(start_inst)`: 打印追踪结果

## 依赖

- Python 3.6+
- 标准库：`re`, `typing`, `dataclasses`

无需额外安装第三方库。

