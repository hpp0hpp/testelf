# 函数 0x2d967c 算法分析报告

## 📋 概述

**函数名称**: `AES_RC4_Hybrid_Encrypt` (原 `sub_2D967C`)  
**地址**: `0x2d967c`  
**大小**: `0x998` 字节  
**算法类型**: **混合加密方案 (AES-128-CBC + RC4 流密码)**

---

## 🔐 整体架构

这是一个高度混淆的混合加密实现，结合了三层安全机制：

```
┌─────────────┐     ┌──────────────┐     ┌──────────┐     ┌─────────┐
│   明文输入   │ --> │ PKCS#7填充   │ --> │ AES-128  │ --> │   RC4   │ --> 密文
│             │     │ + 位运算混淆  │     │   CBC    │     │  流加密  │
└─────────────┘     └──────────────┘     └──────────┘     └─────────┘
```

### 第一层：自定义预处理混淆
- 复杂的位运算混淆 (XOR/AND/OR 组合)
- PKCS#7 填充到 16 字节倍数
- 使用 32 字节循环缓冲区

### 第二层：AES-128-CBC 分组加密
- 标准 AES-128 算法（11 轮密钥）
- CBC 工作模式（需要 IV）
- 包含完整的 AES 变换：SubBytes, ShiftRows, MixColumns, AddRoundKey

### 第三层：RC4 流密码
- 256 字节状态数组
- 密钥调度算法 (KSA)
- 伪随机生成算法 (PRGA)

---

## 📊 函数调用关系图

```
AES_RC4_Hybrid_Encrypt (0x2d967c)
├── PreProcess_PKCS7_Padding (0x2da014)
│   └── 数据预处理与填充
├── Calculate_AES_BlockCount (0x2db14c)
│   └── 计算加密块数
├── Initialize_PlainText_Buffer (0x2d3e00)
│   └── 初始化缓冲区
├── Process_IV_ToByteArray (0x2d0fa4)
│   └── 处理初始化向量
├── RC4_KeyScheduling_KSA (0x2dba7c)
│   └── RC4 密钥调度
├── Extract_AES_Block (0x2dc570)
│   └── 提取 16 字节分组
├── AES_CBC_XOR_WithIV (0x2dc970)
│   └── CBC 模式 XOR
├── Convert_To_AES_StateMatrix (0x2dccf4)
│   └── 转换为 4×4 矩阵
├── AES_EncryptRounds_Entry (0x2dcfcc)
│   ├── AES128_KeyExpansion (0x2d1d30)
│   │   └── 生成 11 轮密钥
│   ├── AES_AddRoundKey_MixColumns (0x2d7730)
│   │   └── 轮密钥加和列混淆
│   └── AES_SubBytes_SBox (0x2d44c0)
│       └── S-盒非线性替换
└── Final_Encrypt_Output (0x2d01dc)
    ├── RC4_Initialize_SBox (0x2cfb58)
    │   └── 初始化 RC4 S-盒
    └── RC4_Encrypt_PRGA (0x2d050c)
        └── RC4 伪随机生成与加密
```

---

## 🔍 关键函数详解

### 1. PreProcess_PKCS7_Padding (0x2da014)
**功能**: 数据预处理与 PKCS#7 填充  
**算法**:
- 使用自定义随机数生成器（初值 `-559038737`，4 轮迭代）
- 对明文每个字节进行复杂位运算混淆
- 实现 PKCS#7 填充算法
- 检测是否需要额外的填充块

**关键特征**:
```c
// 随机数生成
v47 = -559038737;
for (n4 = 0; n4 < 4; n4++) {
    v47 = (v6 ^ 0x5754AC8E | v47 ^ 0xA8AB5371) 
        ^ (v6 ^ 0xA8AB5371 | v47 ^ 0x5754AC8E);
}

// PKCS#7 填充计算
padding_byte = 16 - (length & 0xF);
```

---

### 2. RC4_KeyScheduling_KSA (0x2dba7c)
**功能**: RC4 密钥调度算法  
**算法**: 标准 RC4 KSA
```c
// 初始化 S-盒
for (i = 0; i < 256; i++)
    S[i] = i;

// 置换
j = 0;
for (i = 0; i < 256; i++) {
    j = (j + S[i] + key[i % key_length]) % 256;
    swap(S[i], S[j]);
}
```

**特征**:
- 256 字节状态数组
- 基于密钥的伪随机置换
- 额外的混淆层（位运算）

---

### 3. AES128_KeyExpansion (0x2d1d30)
**功能**: AES-128 密钥扩展  
**算法**: Rijndael 密钥调度  
**参数**:
- 输入: 128 位（16 字节）原始密钥
- 输出: 11 个轮密钥（176 字节）
- 轮数: 10 轮加密 + 1 轮初始

**实现**:
```c
allocate_round_keys(round_keys, 11);

// 提取密钥的不同部分
w0 = extract_bytes_at_offset(key, 0);
w1 = extract_bytes_at_offset(key, 4);
w2 = extract_bytes_at_offset(key, 8);
w3 = extract_bytes_at_offset(key, 12);

// 生成轮密钥
for (round = 0; round < 11; round++) {
    // 密钥调度核心算法
    // RotWord, SubWord, Rcon
}
```

---

### 4. AES_SubBytes_SBox (0x2d44c0)
**功能**: AES SubBytes 变换  
**算法**: S-盒替换  
**S-盒位置**: `0x1E1C10` (已重命名为 `AES_Standard_SBox`)

**标准 AES S-盒** (前16字节):
```
63 7C 77 7B F2 6B 6F C5 30 01 67 2B FE D7 AB 76
```

**实现**:
```c
for (i = 0; i < 4; i++) {
    for (j = 0; j < 4; j++) {
        byte = state[i][j];
        high = (byte >> 4) & 0x0F;  // 高 4 位
        low = byte & 0x0F;           // 低 4 位
        state[i][j] = S_Box[high * 16 + low];
    }
}
```

---

### 5. AES_AddRoundKey_MixColumns (0x2d7730)
**功能**: 轮密钥加法 + 列混淆  
**算法**: GF(2^8) 域运算

**AddRoundKey**:
```c
state[i][j] ^= round_key[round][i][j];
```

**MixColumns** (在 GF(2^8) 域上):
```
| 02 03 01 01 |   | s0 |
| 01 02 03 01 | × | s1 |
| 01 01 02 03 |   | s2 |
| 03 01 01 02 |   | s3 |
```

---

### 6. AES_CBC_XOR_WithIV (0x2dc970)
**功能**: CBC 模式异或操作  
**算法**: 
```c
if (block == 0)
    cipher_input = plaintext XOR IV;
else
    cipher_input = plaintext XOR previous_ciphertext;
```

**实现**: 对 16 字节逐字节异或
```c
for (i = 0; i < 16; i++) {
    plaintext[i] ^= iv[i];
}
```

---

### 7. RC4_Encrypt_PRGA (0x2d050c)
**功能**: RC4 伪随机生成算法  
**算法**: RC4 PRGA + SIMD 优化

```c
i = j = 0;
while (generating_output) {
    i = (i + 1) % 256;
    j = (j + S[i]) % 256;
    swap(S[i], S[j]);
    K = S[(S[i] + S[j]) % 256];
    output = plaintext XOR K;
}
```

**优化**: 使用 ARM NEON SIMD 指令
- `vorrq_s8`: 向量 OR
- `vandq_s8`: 向量 AND
- `veorq_s8`: 向量 XOR

---

## 🎯 加密流程详解

### 完整加密步骤

```
步骤 1: 预处理 (PreProcess_PKCS7_Padding)
       ├─ 计算需要的填充字节数
       ├─ 对每个字节进行位运算混淆
       └─ 添加 PKCS#7 填充

步骤 2: 计算分组数 (Calculate_AES_BlockCount)
       └─ block_count = ceil(length / 16)

步骤 3-4: 初始化
       ├─ 初始化明文缓冲区
       └─ 处理 IV 转为字节数组

步骤 5: 密钥准备 (RC4_KeyScheduling_KSA)
       ├─ 初始化 256 字节状态数组
       └─ 基于密钥进行置换

步骤 6-9: AES-128-CBC 加密 (每个 16 字节块)
       ├─ 提取当前分组
       ├─ 与 IV/前一密文块 XOR
       ├─ 转换为 4×4 状态矩阵
       └─ 执行 AES 加密轮
           ├─ 初始轮密钥加 (Round 0)
           ├─ 9 轮标准变换 (Round 1-9)
           │   ├─ SubBytes (S-盒)
           │   ├─ ShiftRows
           │   ├─ MixColumns
           │   └─ AddRoundKey
           └─ 最终轮 (Round 10)
               ├─ SubBytes
               ├─ ShiftRows
               └─ AddRoundKey

步骤 10: RC4 后处理 (Final_Encrypt_Output)
       ├─ 初始化 RC4 S-盒
       ├─ 生成伪随机密钥流
       └─ 与 AES 密文异或
```

---

## 🛠️ 已添加的注释和重命名

### 主要函数重命名
| 原函数名 | 新函数名 | 功能 |
|---------|---------|------|
| `sub_2D967C` | `AES_RC4_Hybrid_Encrypt` | 混合加密主函数 |
| `sub_2DA014` | `PreProcess_PKCS7_Padding` | 预处理和填充 |
| `sub_2DBA7C` | `RC4_KeyScheduling_KSA` | RC4 密钥调度 |
| `sub_2D1D30` | `AES128_KeyExpansion` | AES 密钥扩展 |
| `sub_2D44C0` | `AES_SubBytes_SBox` | S-盒替换 |
| `sub_2D7730` | `AES_AddRoundKey_MixColumns` | 轮密钥加与列混淆 |
| `sub_2DC970` | `AES_CBC_XOR_WithIV` | CBC 模式 XOR |
| `sub_2D050C` | `RC4_Encrypt_PRGA` | RC4 加密 |

### 全局数据重命名
| 原名称 | 新名称 | 说明 |
|-------|-------|------|
| `xmmword_1E1C10` | `AES_Standard_SBox` | AES 标准 S-盒 |
| `byte_1E1770` | `Obfuscation_Constants` | 混淆常量表 |

### 辅助函数重命名
- `get_byte_iterator` - 获取字节迭代器
- `extract_bytes_at_offset` - 按偏移提取字节
- `get_round_key_address` - 计算轮密钥地址
- `get_matrix_row` - 获取矩阵行
- `array_at` - 数组访问
- `swap_array_elements` - 交换数组元素

---

## ⚠️ 安全性评估

### ✅ 优点
1. **使用工业标准 AES-128**: 目前仍被认为是安全的对称加密算法
2. **CBC 模式**: 相比 ECB 更安全，提供更好的密文随机性
3. **正确的填充**: 使用标准 PKCS#7 填充
4. **大量代码混淆**: 增加逆向工程难度

### ⚠️ 潜在问题
1. **RC4 已不安全**: RC4 存在多个已知漏洞，不应在新系统中使用
2. **双重加密过度设计**: AES 后再用 RC4 可能引入新的弱点而非增强安全
3. **代码混淆 ≠ 密码强度**: 位运算混淆仅增加分析难度，不提升实际安全性
4. **缺少认证**: 没有 MAC/HMAC，容易受到选择密文攻击

### 📌 建议
- 如果可能，建议使用 **AES-128-GCM** 或 **AES-256-GCM** (带认证)
- 移除 RC4 层，依赖 AES 的安全性
- 添加消息认证码 (MAC) 防止篡改

---

## 📝 IDA Pro 中的注释位置

所有关键位置已添加中文注释：

### 主函数 (0x2d967c)
- `0x2d96f0`: 步骤1 - 数据预处理
- `0x2d9738`: 初始化混淆缓冲区
- `0x2d977c`: 核心混淆循环
- `0x2d9814`: 获取并混淆字节
- `0x2d9ab0`: 写入混淆结果
- `0x2d9acc`: 步骤2 - 计算块数
- `0x2d9af4`: 步骤3 - 初始化缓冲区
- `0x2d9b00`: 步骤4 - 处理 IV
- `0x2d9b18`: 步骤5 - RC4 密钥调度
- `0x2d9b74`: 步骤6 - 提取分组
- `0x2d9b80`: 步骤7 - CBC XOR
- `0x2d9b8c`: 步骤8 - 状态矩阵转换
- `0x2d9b9c`: 步骤9 - AES 加密
- `0x2d9d78`: 步骤10 - 最终输出

### 全局数据
- `0x1E1C10`: AES 标准 S-盒
- `0x1E1770`: 混淆常量表

---

## 🎓 技术要点

### AES-128 关键参数
- **密钥长度**: 128 位 (16 字节)
- **分组大小**: 128 位 (16 字节)
- **轮数**: 10 轮 + 初始轮密钥加
- **轮密钥**: 11 个 (176 字节总计)
- **状态矩阵**: 4×4 字节

### RC4 关键参数
- **状态数组**: 256 字节
- **密钥长度**: 可变 (本例中根据输入)
- **输出**: 伪随机字节流

### 混淆技术
1. **位运算混淆**: XOR、AND、OR 的复杂组合
2. **控制流混淆**: 多层函数调用
3. **常量混淆**: 魔术数字和查表
4. **SIMD 指令**: ARM NEON 向量操作

---

## 🔧 逆向工程提示

### 识别 AES 的标志
1. ✅ 256 字节 S-盒 (以 `63 7C 77 7B F2` 开头)
2. ✅ 4×4 状态矩阵操作
3. ✅ 11 轮密钥（AES-128）
4. ✅ 固定的循环次数（10 或 11）

### 识别 RC4 的标志
1. ✅ 256 字节状态数组初始化为 0-255
2. ✅ 两个索引变量 i, j
3. ✅ swap 操作
4. ✅ 密钥调度 + 伪随机生成两阶段

### 识别 CBC 模式
1. ✅ 需要 IV（初始化向量）
2. ✅ 前一个密文块参与下一块加密
3. ✅ 16 字节 XOR 操作

---

## 📚 参考资料

### AES (Rijndael)
- FIPS 197: Advanced Encryption Standard
- S-盒定义: Rijndael S-box specification
- 密钥扩展: Key expansion algorithm

### RC4
- RC4 密钥调度算法 (KSA)
- RC4 伪随机生成算法 (PRGA)
- 已知漏洞: Fluhrer-Mantin-Shamir attack

### PKCS#7
- RFC 5652: Cryptographic Message Syntax
- Padding scheme for block ciphers

---

## 📞 总结

函数 `0x2d967c` (`AES_RC4_Hybrid_Encrypt`) 实现了一个**三层混合加密方案**：

1. **预处理层**: PKCS#7 填充 + 自定义位运算混淆
2. **AES 层**: 标准 AES-128-CBC 分组加密
3. **RC4 层**: 流密码后处理

整个实现经过**高度混淆**，使用了复杂的位运算、多层函数调用和 SIMD 优化。实际的密码强度主要依赖于 **AES-128** 部分，RC4 层和混淆层更多是为了增加逆向分析的难度。

---

**分析完成时间**: 2025年11月7日  
**工具**: IDA Pro + 人工分析  
**置信度**: 高 (基于标准 AES S-盒识别和算法模式匹配)

