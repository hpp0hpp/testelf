# AES 算法魔改分析报告

## ⚠️ 重要发现：这是一个高度魔改的伪AES实现！

经过深入分析，我发现这个实现**并非标准AES算法**，而是一个**使用AES结构和组件的自定义加密算法**。

---

## 🔴 关键魔改点

### 1. **SubBytes 函数的魔改** (0x2d44c0)

#### 标准AES SubBytes应该：
```c
// 标准实现：使用固定的256字节S-盒
byte = state[i][j];
state[i][j] = AES_SBOX[byte];
```

#### 实际实现中的问题：

**问题1：S-盒来源异常**
```c
// 行25: 使用 round_keys 作为 S-盒查找！
matrix_row_1 = get_matrix_row(round_keys_1, (unsigned __int64)*element_at >> 4);
```
这里用**轮密钥结构**(`round_keys`)而非固定S-盒表来查找！这是**严重偏离**。

**问题2：索引计算被严重混淆**
```c
// 行28-37: 复杂的位运算混淆索引
v11 = (*element_at_1 & 0x13 | 0x70000080) ^ *element_at_1 & 0xEC;
v12 = (v11 ^ 0x8FFFFF7F) & 0x1FFB6122 | v11 & 0xDD;
v13 = (v12 ^ 0x1FFB61A2) & 0x1DAA4105 | 
      (v11 ^ 0x8FFFFF7F) & (v11 ^ 0x8251227A) & 0xA25122FF;
v14 = ((v12 ^ 0x40009409) & 0x5921B58B | v12 & 0x6DA4074) ^ 0x5FFBF5A4 | 
      ((unsigned __int8)v12 ^ 2) & 0xF;

// 最终索引计算
index = (v14 ^ 0xA6FBABF5 ^ ((v13 ^ 0x5DAEDD0A) & 0x6FB8B25 | v13 & 0xB90060DA))
        & (v13 ^ 0x5DAEDD0A | v14);
```

标准AES只需要简单的字节值作为索引，而这里经过了**4-5层复杂位运算**！

**魔改总结：**
- ❌ 不使用固定的AES S-盒
- ❌ 使用密钥相关的查找表（可能是动态S-盒）
- ❌ 索引计算被严重混淆
- ⚠️ 这可能实现了**密钥相关的S-盒**（类似某些AES变种）

---

### 2. **AddRoundKey + MixColumns 的魔改** (0x2d7730)

#### 标准AES应该：
```c
// AddRoundKey: 简单XOR
state[i][j] ^= round_key[i][j];

// MixColumns: GF(2^8)域上的矩阵乘法
// 使用固定矩阵:
// [ 02 03 01 01 ]
// [ 01 02 03 01 ]
// [ 01 01 02 03 ]
// [ 03 01 01 02 ]
```

#### 实际实现中的问题：

**问题：完全看不到标准的实现**
```c
// 行46-52: 完全混淆的操作
v16 = ((v12 ^ 4) & 0xD4 | v12 & 0x2B) ^ 0xFB | v12;
v17 = (~v15 ^ 0xA9) & 0xBE | v15 & 0x41;
v18 = (v17 ^ 0xA8) & ((v15 | ~v15) ^ 0xBE) | 
      (v17 ^ 0x57) & ((v15 | ~v15) ^ 0x41);
v19 = v15 | ~v15;
v20 = v16 | ~v12;
v21 = (v12 ^ 8 | 2) ^ v12 & 0x96 ^ 0x9C ^ (v16 | (v16 ^ 0x96) & ~v16);

// 最终结果
*element_at = (v18 | ~v19) ^ (v21 ^ v20 | ~(v21 | v20));
```

**魔改总结：**
- ❌ 看不到标准的XOR操作（AddRoundKey）
- ❌ 看不到GF(2^8)域乘法（MixColumns）
- ❌ 大量复杂的位运算混淆
- ⚠️ 可能是**自定义的混淆变换**，替代了标准MixColumns

---

### 3. **ShiftRows 变换缺失？**

#### 标准AES需要：
```c
// ShiftRows: 状态矩阵的行循环移位
// 第0行: 不移位
// 第1行: 左移1字节
// 第2行: 左移2字节
// 第3行: 左移3字节
```

#### 实际情况：
在整个代码流程中，我**没有找到明确的ShiftRows实现**！

可能的情况：
1. ShiftRows被合并到其他变换中（通过索引重排）
2. ShiftRows被完全省略（简化变种）
3. ShiftRows被隐藏在状态矩阵的读写顺序中

**魔改总结：**
- ⚠️ ShiftRows变换不明显或缺失
- 这会**显著改变**AES的扩散特性

---

## 📊 AES标准 vs 实际实现对比

| AES组件 | 标准实现 | 实际实现 | 魔改程度 |
|---------|---------|---------|---------|
| **SubBytes** | 固定256字节S-盒 | 使用round_keys作为查找表 + 复杂索引计算 | 🔴 **严重** |
| **ShiftRows** | 固定的行循环移位 | 未找到明确实现 | 🟡 **中等** |
| **MixColumns** | GF(2^8)矩阵乘法 | 自定义位运算混淆 | 🔴 **严重** |
| **AddRoundKey** | 简单XOR | 被混淆到MixColumns中 | 🟡 **中等** |
| **密钥扩展** | 标准Rijndael算法 | 部分标准（11轮密钥） | 🟢 **轻微** |
| **S-盒数据** | 固定常量表(0x1E1C10) | 存在但使用方式异常 | 🟡 **中等** |

---

## 🎭 混淆技术分析

### 混淆层次

1. **算法层混淆**
   - 使用AES的整体结构（轮函数、状态矩阵）
   - 但核心变换（SubBytes、MixColumns）被魔改

2. **实现层混淆**
   - 大量位运算掩盖真实操作
   - 使用魔术常量（0x8FFFFF7F, 0x1FFB6122等）
   - 多层嵌套的位运算

3. **代码层混淆**
   - 复杂的函数调用链
   - 变量命名混乱
   - 控制流混淆

### 混淆目的

```
标准AES特性              实际实现特性
┌──────────────┐        ┌──────────────┐
│ 公开算法      │        │ 专有算法      │
│ 可互操作      │   VS   │ 不兼容       │
│ 易于验证      │        │ 难以分析      │
│ 标准实现      │        │ 自定义实现    │
└──────────────┘        └──────────────┘
```

---

## 🔍 魔改的可能原因

### 1. **实现密钥相关的S-盒**
```
标准AES: 所有密钥使用相同的S-盒
魔改版: S-盒可能依赖于密钥/轮密钥

优点: 增加密钥依赖性，理论上更安全
缺点: 偏离标准，未经充分密码分析
```

### 2. **防止标准AES工具解密**
```
目的: 确保只有专有实现可以解密
效果: 通用AES库无法解密此密文
```

### 3. **专利/知识产权保护**
```
通过魔改避免直接使用标准AES
可能声称为"改进的AES"或"AES变种"
```

### 4. **混淆真实算法**
```
表面看起来像AES（有S-盒、轮函数）
实际是自定义的分组密码
利用AES的声誉但不承担标准约束
```

---

## ⚠️ 安全性评估

### 🔴 重大风险

1. **未经充分密码分析**
   - 标准AES经过20+年的公开分析
   - 魔改版没有经过类似的审查
   - 可能存在未知弱点

2. **S-盒设计风险**
   ```
   如果S-盒依赖于轮密钥:
   - 弱密钥可能导致弱S-盒
   - 某些密钥组合可能降低非线性度
   - 差分/线性密码分析抗性未知
   ```

3. **MixColumns魔改**
   ```
   标准MixColumns提供最优扩散特性
   自定义实现的扩散性能未知
   可能存在相关密钥攻击的弱点
   ```

4. **ShiftRows缺失/简化**
   ```
   削弱雪崩效应
   可能存在某些比特不扩散的问题
   ```

### 🟡 中等风险

5. **组合加密不一定更安全**
   ```
   AES(魔改) + RC4 的组合:
   - RC4本身有已知弱点
   - 两个算法的组合未经验证
   - 可能引入新的攻击面
   ```

6. **实现复杂度**
   ```
   过度复杂的实现容易出错
   位运算混淆可能掩盖实现bug
   ```

---

## 🎯 实际算法分类

根据分析，这个实现应归类为：

```
┌─────────────────────────────────────┐
│  类型: 自定义分组密码                │
│  基础: AES架构 + 魔改变换             │
│  特征: 密钥相关S-盒(可能) + 自定义扩散 │
│  安全性: 未知(未经公开分析)           │
└─────────────────────────────────────┘
```

**不是：**
- ❌ 标准AES-128
- ❌ 简单的AES混淆实现
- ❌ 已知的AES变种（如AES-NI指令集）

**可能是：**
- ✅ 基于AES结构的专有算法
- ✅ "AES-inspired" 自定义密码
- ✅ 为特定应用设计的加密方案

---

## 📝 技术细节总结

### SubBytes 魔改细节

**推测的实现逻辑：**
```python
# 标准AES
def standard_subbytes(byte):
    return SBOX[byte]

# 魔改版本（推测）
def modified_subbytes(byte, round_keys):
    # 1. 复杂的索引计算
    obfuscated_index = complex_bit_operations(byte)
    
    # 2. 使用轮密钥作为动态S-盒
    row = extract_row_from_roundkeys(obfuscated_index >> 4)
    col = obfuscated_index & 0x0F
    
    # 3. 从动态结构中查找
    return row[col]
```

### MixColumns 魔改细节

**可能的实现：**
```python
# 标准AES MixColumns (GF(2^8)域)
def standard_mixcolumns(col):
    return [
        mul_gf256(0x02, col[0]) ^ mul_gf256(0x03, col[1]) ^ col[2] ^ col[3],
        col[0] ^ mul_gf256(0x02, col[1]) ^ mul_gf256(0x03, col[2]) ^ col[3],
        col[0] ^ col[1] ^ mul_gf256(0x02, col[2]) ^ mul_gf256(0x03, col[3]),
        mul_gf256(0x03, col[0]) ^ col[1] ^ col[2] ^ mul_gf256(0x02, col[3])
    ]

# 魔改版本（推测）
def modified_transform(byte1, byte2):
    # 使用复杂位运算代替GF(2^8)乘法
    # 可能不是真正的有限域运算
    result = complex_bit_operations(byte1, byte2)
    return result
```

---

## 💡 解密建议

### 如果需要解密此算法：

1. **不能使用标准AES库**
   - OpenSSL、Crypto++等都无法解密
   - 必须重新实现魔改逻辑

2. **关键挑战：**
   - 理解SubBytes的动态S-盒生成
   - 逆向MixColumns的自定义变换
   - 确定ShiftRows是否存在及其形式

3. **建议步骤：**
   ```
   Step 1: 完整提取所有变换函数的汇编
   Step 2: 逐字节跟踪数据流
   Step 3: 识别可逆操作
   Step 4: 实现逆向变换
   Step 5: 验证解密正确性
   ```

4. **简化方案：**
   - 如果只需要加密（不需解密）
   - 可以直接调用原始函数
   - 或完整dump运行时内存

---

## 📚 相关技术

### 已知的AES变种参考

1. **Rijndael (AES祖先)**
   - 支持可变块大小和密钥长度
   - 本实现的变化更激进

2. **White-box AES**
   - 混淆实现以隐藏密钥
   - 但通常保留算法结构
   - 本实现更像是算法魔改

3. **PRESENT, PRINCE等轻量级密码**
   - 简化的类AES结构
   - 经过充分密码分析
   - 本实现未经此过程

### 类似的魔改案例

- **ZUC流密码**：中国的专有算法
- **SM4分组密码**：类似AES但细节不同
- **GOST 28147-89**：俄罗斯的分组密码

---

## 🔒 结论

### 核心发现

这**不是标准AES算法**，而是一个：

```
基于AES架构的自定义分组密码
├─ 使用AES的整体结构（轮函数、状态矩阵）
├─ 魔改SubBytes（密钥相关S-盒？）
├─ 魔改MixColumns（自定义扩散）
├─ 可能简化/省略ShiftRows
└─ 加上RC4流密码后处理
```

### 魔改程度评级

**整体魔改程度: 🔴 严重 (7/10)**

- SubBytes: 🔴🔴🔴🔴🔴 (5/5)
- MixColumns: 🔴🔴🔴🔴🔴 (5/5)
- ShiftRows: 🟡🟡🟡 (3/5)
- AddRoundKey: 🟡🟡 (2/5)
- 密钥扩展: 🟢 (1/5)

### 实际影响

1. **不能用标准AES工具解密** ✅
2. **增加逆向工程难度** ✅
3. **安全性未经验证** ⚠️
4. **可能存在未知弱点** ⚠️

### 建议

- 如果这是您自己的项目：考虑使用标准AES-GCM
- 如果在逆向分析：需要完整重新实现所有魔改逻辑
- 如果在安全审计：**高度建议进行专业密码分析**

---

**分析日期**: 2025年11月7日  
**置信度**: 高 (基于详细反编译代码分析)  
**风险等级**: ⚠️ **中-高** (未经验证的自定义密码)

